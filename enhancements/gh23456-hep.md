# Securing In-Cluster Virtual Machines and Pods Communication with mTLS

---

## Summary

Currently in Harvester, communications between in-cluster virtual machines (VMs) and pods are unencrypted, exposing user workloads to the risk of traffic spoofing and man-in-the-middle (MITM) attacks. This enhancement proposes securing all VM-pod in-cluster network communications by enabling automated mutual TLS (mTLS) using a service mesh such as Linkerd or Istio. By leveraging mTLS, Harvester will enforce encrypted traffic and mutual service identity verification, facilitating a zero-trust network model. The enhancement will include strategies for seamless certificate management with minimal disruption to running workloads.

### Related Issues

- [Harvester GitHub: Security Enhancements](https://github.com/harvester/harvester/issues?q=is%3Aissue+security+mtls)
- [KubeVirt mTLS Issue](https://github.com/kubevirt/kubevirt/issues?q=mtls)
- [Longhorn Storage mTLS Discussions](https://github.com/longhorn/longhorn/issues?q=mtls)

---

## Motivation

While enabling users to run VMs alongside Kubernetes-native workloads, Harvester presently allows plaintext communication in the cluster. This presents critical risks:
- Unauthorized interception or modification of traffic between VMs and pods
- Lateral movement by attackers within the cluster
- Difficulty in enforcing strict access rules and service authenticity

By implementing mTLS, cluster trust boundaries are significantly strengthened, ensuring only authorized workloads communicate and all traffic is encrypted in transit.

### Goals

- All in-cluster network traffic between VMs and pods is encrypted using mTLS.
- Service identity is automatically verified for all internal communications.
- Certificate lifecycle (issuance, rotation, revocation) is automated and minimally disruptive.
- The approach is compatible with existing Harvester workloads (KubeVirt, Longhorn, etc).
- User configuration is minimal and well-documented.

### Non-goals

- Securing external (north-south) traffic to/from the Harvester cluster.
- Supporting older versions of service meshes or VMs not compatible with mTLS injection.
- Providing UI configuration for advanced mTLS features (phase 1).

---

## Proposal

To secure intra-cluster communication, we propose integrating Harvester clusters with a Kubernetes-native service mesh (Linkerd or Istio). The service mesh will inject sidecars into applicable pods and integrate with KubeVirt launchers (VMs) to facilitate automatic mTLS for all service-to-service traffic.

The selected service mesh will:
- Transparently handle certificate generation, distribution, and rotation.
- Perform traffic interception and encryption between services and VMs.
- Provide administration CRDs to allow opt-in/opt-out policies.

#### Example Architecture Diagram

![mTLS Service Mesh Integration Overview](https://raw.githubusercontent.com/example/image-repo/main/mtls-architecture.png)

### User Stories

#### Story 1: Secure Pod-to-VM Communication

*Before*: User workloads exchanging sensitive data could be intercepted if running as a pod and a VM in the same cluster.
*After*: All pod-to-VM traffic is transparently encrypted; unauthorized pods cannot pretend to be VMs.

#### Story 2: Policy-Driven Certificate Management

*Before*: Users must manually manage service credentials/certificates if they want encryption.
*After*: Certificates are automatically issued and rotated, requiring little-to-no user interaction.

### User Experience In Detail

- Existing workloads require no code changes; enabling mTLS is done via mesh configuration.
- Example YAML to enable injection for a namespace:

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: workloads
  labels:
    istio-injection: enabled
```

- VM manifests are annotated so mesh injects a sidecar for mTLS (example with KubeVirt):

```yaml
apiVersion: kubevirt.io/v1
kind: VirtualMachineInstance
metadata:
  annotations:
    sidecar.istio.io/inject: "true"
# other spec...
```

- Mesh operator provides CLI or CRDs to enable/disable mTLS per namespace or workload.
- All certificate challenges, renewals, and revocations are logged for auditing.

### API Changes

- Introduce CRDs or annotation patterns for opting workloads into mTLS.
- Minor updates for webhooks mutating deployments/pods/VMs to signal mesh injection.

---

## Design

### Implementation Overview

1. Evaluate and select a service mesh (Linkerd/Istio) for best Harvester/KubeVirt compatibility.
2. Integrate mTLS mesh with KubeVirt VMs by patching launchers/hypervisor network stack for sidecar support.
3. Update Harvester deployment charts to optionally bundle/manage the mesh.
4. Provide automated and documented upgrade paths for legacy clusters.

**Golang Pseudocode for Injection Admission Webhook:**

```go
func ShouldInjectMesh(pod *corev1.Pod) bool {
    ns := pod.Namespace
    if ns.Labels["istio-injection"] == "enabled" || pod.Annotations["sidecar.istio.io/inject"] == "true" {
        return true
    }
    return false
}
```

### Test Plan

- Deploy test VMs and pods; validate traffic is encrypted with `tcpdump`.
- Simulate certificate expiry and validate rotation is seamless.
- Test disabling mTLS via annotation and ensure fallback.
- Penetration testing against MITM and spoofed connections.

### Upgrade Strategy

- Ship mesh as an optional add-on for existing clusters.
- Provide a “dry-run” mode to evaluate readiness (e.g., check all workloads for compatibility).
- Detailed migration guides for gradual rollout.

---

## Notes

- If using Istio, workload identity can be integrated with SPIFFE for advanced zero-trust.
- Future work: Extend mTLS perimeter to north-south cluster boundaries.
- Images and diagrams use sample endpoints; adjust URLs as needed for Harvester docs.

---

**End of HEP**
